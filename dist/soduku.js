/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _layout_Layout_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n/* harmony import */ var _Soduku_SodukuGenerator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);\n/* harmony import */ var _styles_main_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);\n/* harmony import */ var _styles_main_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_styles_main_css__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nvar SODUKU_BOARD = document.getElementById(\"soduku-board\");\nvar sodukuGen = new _Soduku_SodukuGenerator_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\nsodukuGen.generate();\nvar layout = new _layout_Layout_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](SODUKU_BOARD, sodukuGen);\nlayout.draw();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pbmRleC5qcz9iNjM1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMYXlvdXQgZnJvbSAnLi9sYXlvdXQvTGF5b3V0LmpzJ1xuaW1wb3J0IFNvZHVrdUdlbmVyYXRvciBmcm9tICcuL1NvZHVrdS9Tb2R1a3VHZW5lcmF0b3IuanMnXG5cbmltcG9ydCAnLi9zdHlsZXMvbWFpbi5jc3MnXG5cbmNvbnN0IFNPRFVLVV9CT0FSRCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic29kdWt1LWJvYXJkXCIpXG5cbnZhciBzb2R1a3VHZW4gPSBuZXcgU29kdWt1R2VuZXJhdG9yKClcbnNvZHVrdUdlbi5nZW5lcmF0ZSgpXG5cbmxldCBsYXlvdXQgPSBuZXcgTGF5b3V0KFNPRFVLVV9CT0FSRCwgc29kdWt1R2VuKVxubGF5b3V0LmRyYXcoKSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction createElem() {\n  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"div\";\n  var attr_list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var row_elem = document.createElement(type);\n\n  if (attr_list.length > 0) {\n    attr_list.forEach(function (attr) {\n      var prop = row_elem.setAttribute(attr.type, attr.value);\n    });\n  }\n\n  return row_elem;\n}\n\nfunction appendChild(parent, child) {\n  parent.appendChild(child);\n}\n\nvar Layout = /*#__PURE__*/function () {\n  function Layout(container, generator) {\n    _classCallCheck(this, Layout);\n\n    this.container = container;\n    this.generator = generator;\n  } // Draw function creates the soduku layout. It \n  // traverses left to right and then move to the next line\n  // if no values are provided, it creates a blank (9x9)\n  // diagram\n  //\n  // cell_values : The values which has to be plotted\n\n\n  _createClass(Layout, [{\n    key: \"draw\",\n    value: function draw() {\n      var _this = this;\n\n      var cell_values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var ROW_NO = 8,\n          COL_NO = 8;\n\n      var _loop = function _loop(r) {\n        //0 indexing\n        var row_class_name = \"row\";\n\n        if (r == 0) {\n          // for the top row we need a thick top border\n          row_class_name += \" top_row\";\n        } else if ((r + 1) % 3 === 0) {\n          //for every third row we need a thick bottom border\n          row_class_name += \" row_divider\";\n        } //create the rows & add to the board\n\n\n        var row_attrs = [{\n          type: 'id',\n          value: \"row_\".concat(r)\n        }, {\n          type: 'class',\n          value: row_class_name\n        }];\n        var row_cont = createElem('div', row_attrs);\n        appendChild(_this.container, row_cont); //create the cells inside the rows\n\n        var _loop2 = function _loop2(c) {\n          var cell_class_name = \"cell cell-text\";\n\n          if (c == 0) {\n            //for the left most cells we need a thick left border\n            cell_class_name += \" left-cell\";\n          } else if ((c + 1) % 3 === 0) {\n            //for every third cell we need a thick right border\n            cell_class_name += \" cell_right\";\n          }\n\n          var cell_attr = [{\n            type: 'id',\n            value: \"cell_\".concat(r, \"_\").concat(c)\n          }, {\n            type: 'class',\n            value: cell_class_name\n          }]; //create the cells with the styles\n\n          var cell = createElem('div', cell_attr); //add the text inside the cell\n          //let text = createElem('p', [{type: 'class', value: 'cell-text'}])\n          // let val = this.generator.getCellValue(r, c);\n\n          setTimeout(function () {\n            var val = _this.generator.getCellValue(r, c);\n\n            if (val) {\n              cell.innerHTML = val;\n            } else {//@todo: we need to make the empty cell white, but the folliwng code\n              // somehow hides the border of the row-divider class\n              //cell.classList.add('empty-cell')\n            }\n          }, 1000); //append the text and the cell\n          //appendChild(cell, text)\n\n          appendChild(row_cont, cell);\n        };\n\n        for (var c = 0; c <= COL_NO; c++) {\n          _loop2(c);\n        }\n      };\n\n      for (var r = 0; r <= ROW_NO; r++) {\n        _loop(r);\n      }\n    }\n  }]);\n\n  return Layout;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Layout);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9sYXlvdXQvTGF5b3V0LmpzP2U3MGYiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW0gKHR5cGUgPSBcImRpdlwiLCBhdHRyX2xpc3QgPSBbXSkge1xuICAgIGxldCByb3dfZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSlcblxuICAgIGlmIChhdHRyX2xpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICBhdHRyX2xpc3QuZm9yRWFjaChhdHRyID0+IHtcbiAgICAgICAgICAgIGxldCBwcm9wID0gcm93X2VsZW0uc2V0QXR0cmlidXRlKGF0dHIudHlwZSwgYXR0ci52YWx1ZSlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiByb3dfZWxlbVxufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZChwYXJlbnQsIGNoaWxkKSB7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKVxufVxuXG5cbmNsYXNzIExheW91dCB7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIGdlbmVyYXRvcikge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XG4gICAgfVxuXG4gICAgLy8gRHJhdyBmdW5jdGlvbiBjcmVhdGVzIHRoZSBzb2R1a3UgbGF5b3V0LiBJdCBcbiAgICAvLyB0cmF2ZXJzZXMgbGVmdCB0byByaWdodCBhbmQgdGhlbiBtb3ZlIHRvIHRoZSBuZXh0IGxpbmVcbiAgICAvLyBpZiBubyB2YWx1ZXMgYXJlIHByb3ZpZGVkLCBpdCBjcmVhdGVzIGEgYmxhbmsgKDl4OSlcbiAgICAvLyBkaWFncmFtXG4gICAgLy9cbiAgICAvLyBjZWxsX3ZhbHVlcyA6IFRoZSB2YWx1ZXMgd2hpY2ggaGFzIHRvIGJlIHBsb3R0ZWRcbiAgICBkcmF3IChjZWxsX3ZhbHVlcyA9IFtdKSB7XG4gICAgICAgIGNvbnN0IFJPV19OTyA9IDgsIENPTF9OTyA9IDg7XG4gICAgICAgIGZvcihsZXQgciA9IDA7IHIgPD0gUk9XX05POyByKyspIHsgLy8wIGluZGV4aW5nXG4gICAgICAgICAgICBsZXQgcm93X2NsYXNzX25hbWUgPSBcInJvd1wiO1xuICAgICAgICAgICAgaWYgKHIgPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgdG9wIHJvdyB3ZSBuZWVkIGEgdGhpY2sgdG9wIGJvcmRlclxuICAgICAgICAgICAgICAgIHJvd19jbGFzc19uYW1lICs9IFwiIHRvcF9yb3dcIlxuICAgICAgICAgICAgfSBlbHNlIGlmKChyKzEpICUgMyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vZm9yIGV2ZXJ5IHRoaXJkIHJvdyB3ZSBuZWVkIGEgdGhpY2sgYm90dG9tIGJvcmRlclxuICAgICAgICAgICAgICAgIHJvd19jbGFzc19uYW1lICs9IFwiIHJvd19kaXZpZGVyXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY3JlYXRlIHRoZSByb3dzICYgYWRkIHRvIHRoZSBib2FyZFxuICAgICAgICAgICAgbGV0IHJvd19hdHRycyA9IFtcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2lkJywgdmFsdWU6IGByb3dfJHtyfWB9LFxuICAgICAgICAgICAgICAgIHt0eXBlOiAnY2xhc3MnLCB2YWx1ZTogcm93X2NsYXNzX25hbWV9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgICBsZXQgcm93X2NvbnQgPSBjcmVhdGVFbGVtKCdkaXYnLCByb3dfYXR0cnMpXG4gICAgICAgICAgICBhcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lciwgcm93X2NvbnQpXG4gICAgICAgICAgICAvL2NyZWF0ZSB0aGUgY2VsbHMgaW5zaWRlIHRoZSByb3dzXG4gICAgICAgICAgICBmb3IobGV0IGMgPSAwOyBjIDw9IENPTF9OTzsgYysrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNlbGxfY2xhc3NfbmFtZSA9IFwiY2VsbCBjZWxsLXRleHRcIjtcbiAgICAgICAgICAgICAgICBpZiAoYyA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vZm9yIHRoZSBsZWZ0IG1vc3QgY2VsbHMgd2UgbmVlZCBhIHRoaWNrIGxlZnQgYm9yZGVyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxfY2xhc3NfbmFtZSArPSBcIiBsZWZ0LWNlbGxcIlxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZigoYysxKSAlIDMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy9mb3IgZXZlcnkgdGhpcmQgY2VsbCB3ZSBuZWVkIGEgdGhpY2sgcmlnaHQgYm9yZGVyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxfY2xhc3NfbmFtZSArPSBcIiBjZWxsX3JpZ2h0XCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGNlbGxfYXR0ciA9IFtcbiAgICAgICAgICAgICAgICAgICAge3R5cGU6ICdpZCcsIHZhbHVlOiBgY2VsbF8ke3J9XyR7Y31gfSxcbiAgICAgICAgICAgICAgICAgICAge3R5cGU6ICdjbGFzcycsIHZhbHVlOiBjZWxsX2NsYXNzX25hbWV9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIC8vY3JlYXRlIHRoZSBjZWxscyB3aXRoIHRoZSBzdHlsZXNcbiAgICAgICAgICAgICAgICBsZXQgY2VsbCA9IGNyZWF0ZUVsZW0oJ2RpdicsIGNlbGxfYXR0cilcbiAgICAgICAgICAgICAgICAvL2FkZCB0aGUgdGV4dCBpbnNpZGUgdGhlIGNlbGxcbiAgICAgICAgICAgICAgICAvL2xldCB0ZXh0ID0gY3JlYXRlRWxlbSgncCcsIFt7dHlwZTogJ2NsYXNzJywgdmFsdWU6ICdjZWxsLXRleHQnfV0pXG4gICAgICAgICAgICAgICAgLy8gbGV0IHZhbCA9IHRoaXMuZ2VuZXJhdG9yLmdldENlbGxWYWx1ZShyLCBjKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IHRoaXMuZ2VuZXJhdG9yLmdldENlbGxWYWx1ZShyLCBjKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5pbm5lckhUTUwgPSB2YWxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vQHRvZG86IHdlIG5lZWQgdG8gbWFrZSB0aGUgZW1wdHkgY2VsbCB3aGl0ZSwgYnV0IHRoZSBmb2xsaXduZyBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzb21laG93IGhpZGVzIHRoZSBib3JkZXIgb2YgdGhlIHJvdy1kaXZpZGVyIGNsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NlbGwuY2xhc3NMaXN0LmFkZCgnZW1wdHktY2VsbCcpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAxMDAwKVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vYXBwZW5kIHRoZSB0ZXh0IGFuZCB0aGUgY2VsbFxuICAgICAgICAgICAgICAgIC8vYXBwZW5kQ2hpbGQoY2VsbCwgdGV4dClcbiAgICAgICAgICAgICAgICBhcHBlbmRDaGlsZChyb3dfY29udCwgY2VsbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGF5b3V0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBRUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBREE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFGQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBbEJBO0FBb0JBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFuREE7QUFDQTtBQWtCQTtBQUFBO0FBaUNBO0FBcERBO0FBQ0E7QUFDQTtBQUFBO0FBbURBO0FBQ0E7Ozs7OztBQUdBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/* The engine to generate a soduku Puzzle\n   1. The basic algorith used here is that the 3 x 3 diagonal \n   matrix is independent of each other. We should generate \n   those first\n   2. Then we should randomly choose a number between 1-9\n      and check whether we can place that\n   3. If we can not place that then we go back to the step - 2\n      and repeat\n   4. Post completion of all numbers we randomly remove some \n      of the numbers to create the puzzle\n*/\nfunction getRandomNum() {\n  var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 9;\n  return Math.floor(Math.random() * Math.floor(limit));\n}\n\nfunction suffle(arr) {\n  var copyArr = _toConsumableArray(arr);\n\n  var len = copyArr.length;\n\n  for (var i = 0; i < len; i++) {\n    var rnd_num = getRandomNum(len);\n    var temp = copyArr[i];\n    copyArr[i] = copyArr[rnd_num];\n    copyArr[rnd_num] = temp;\n  }\n\n  return copyArr;\n}\n\nvar SodukuGenerator = /*#__PURE__*/function () {\n  function SodukuGenerator() {\n    _classCallCheck(this, SodukuGenerator);\n\n    this.matrix = [];\n    this.VALUE_ARR = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    this.BLANK_CELL_PLACEHOLDER = 0;\n    this.max_try = 0;\n  }\n  /* \n   * getNumbersInRow returns all the numbers in a specifc row   \n  */\n\n\n  _createClass(SodukuGenerator, [{\n    key: \"getNumbersInRow\",\n    value: function getNumbersInRow(row_no) {\n      var nums = [],\n          col_cntr = 0;\n\n      while (col_cntr < 9) {\n        var val = this.getCellValue(row_no, col_cntr);\n\n        if (Number.isInteger(val)) {\n          nums.push(val);\n        }\n\n        col_cntr++;\n      }\n\n      return nums;\n    }\n  }, {\n    key: \"getRemianingNumbersInRow\",\n    value: function getRemianingNumbersInRow(row_no) {\n      var row_nums = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var nums = row_nums,\n          remainingNums = []; //when no pre-catched row_nums has been passed\n\n      if (nums.length == 0 && Number.isInteger(row_no)) {\n        nums = this.getNumbersInRow(row_no);\n      }\n\n      remainingNums = this.VALUE_ARR.filter(function (num) {\n        return !nums.includes(num);\n      });\n      return remainingNums;\n    }\n    /* \n    * getNumbersInRow returns all the numbers in a specifc column   \n    */\n\n  }, {\n    key: \"getNumbersInColum\",\n    value: function getNumbersInColum(col_no) {\n      var nums = [],\n          row_cntr = 0;\n\n      while (row_cntr < 9) {\n        var val = this.getCellValue(row_cntr, col_no);\n\n        if (Number.isInteger(val)) {\n          nums.push(val);\n        }\n\n        row_cntr++;\n      }\n\n      return nums;\n    }\n  }, {\n    key: \"getRemianingNumbersInColum\",\n    value: function getRemianingNumbersInColum(col_no) {\n      var col_nums = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var nums = col_nums,\n          remainingNums = [];\n\n      if (nums.length == 0 && Number.isInteger(col_no)) {\n        nums = this.getNumbersInColum(col_no);\n      }\n\n      remainingNums = this.VALUE_ARR.filter(function (num) {\n        return !nums.includes(num);\n      });\n      return remainingNums;\n    }\n  }, {\n    key: \"getMatrixLimit\",\n    value: function getMatrixLimit(row_no, col_no) {\n      var matrix_start_row, matrix_end_row, matrix_start_col, matrix_end_col;\n      matrix_start_row = Math.floor(row_no / 3) * 3;\n      matrix_end_row = matrix_start_row + 2;\n      matrix_start_col = Math.floor(col_no / 3) * 3;\n      matrix_end_col = matrix_start_col + 2;\n      return {\n        'm_s_r': matrix_start_row,\n        'm_e_r': matrix_end_row,\n        'm_s_c': matrix_start_col,\n        'm_e_c': matrix_end_col\n      };\n    }\n    /* \n    * getNumbersInSubMatrix returns all the numbers in a specifc sub-matrix   \n    */\n\n  }, {\n    key: \"getNumbersInSubMatrix\",\n    value: function getNumbersInSubMatrix(row_no, col_no) {\n      var isFlat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var nums = [];\n      var matrix_start_row, matrix_end_row, matrix_start_col, matrix_end_col;\n      var matrix_cords = this.getMatrixLimit(row_no, col_no);\n      matrix_start_row = matrix_cords.m_s_r;\n      matrix_end_row = matrix_cords.m_e_r;\n      matrix_start_col = matrix_cords.m_s_c;\n      matrix_end_col = matrix_cords.m_e_c; //get the values of this matrix\n\n      for (var row = matrix_start_row; row <= matrix_end_row; row++) {\n        nums[row] = [];\n\n        for (var col = matrix_start_col; col <= matrix_end_col; col++) {\n          var val = this.getCellValue(row, col);\n\n          if (Number.isInteger(val)) {\n            nums[row].push(val);\n          }\n        }\n      }\n\n      return nums = isFlat ? nums.flat() : nums;\n    }\n  }, {\n    key: \"getRemianingNumbersInSubMatrix\",\n    value: function getRemianingNumbersInSubMatrix(row_no, col_no) {\n      var sunMatrix_nums = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var nums = sunMatrix_nums,\n          remainingNums = [];\n\n      if (nums.length == 0 && Number.isInteger(col_no) && Number.isInteger(row_no)) {\n        nums = this.getNumbersInSubMatrix(row_no, col_no);\n      }\n\n      remainingNums = this.VALUE_ARR.filter(function (num) {\n        return !nums.includes(num);\n      });\n      return remainingNums;\n    }\n    /*\n     * Try to suffle previous numbers in this row to find a\n     * duitable number for this cell\n     * As we are backtracking only on the row, we need not to\n     * newly derive row numbers\n     */\n\n  }, {\n    key: \"backtrackOptimization\",\n    value: function backtrackOptimization(row_no, col_no) {\n      var row_nums = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var col_nums = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n      var sub_matrix_nums = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n\n      /*\n      * 1. Which number(s) in this row are yet to be filled \n      * 2. Which number(s) can be filled in this column\n      * 3. Which number(s) can be filled in this sub-matrix\n      */\n      var remRowNums = this.getRemianingNumbersInRow(row_no);\n      var remColNums = this.getRemianingNumbersInColum(col_no);\n      var remSubMatrxNum, valsInTheTargetCol, valsInTheTargetMatrix, numberLeftInRow;\n      var optNum = -1; //case - 1: When the row has only one item left to fill\n\n      if (false) { var _valsInTheTargetMatrix, _valsInTheTargetCol, _remSubMatrxNum, num, i, _numberLeftInRow; } else {\n        //debugger;\n        for (var _i = col_no - 1; _i >= 0; _i--) {\n          var _num = row_nums[_i]; //check whether this number can be placed in the \n          //required column (col_num)\n\n          if (remColNums.includes(_num)) {\n            //We have to find that whether the sub-matrix has this\n            //num other than it's own part of the row itself\n            remSubMatrxNum = this.getNumbersInSubMatrix(row_no, col_no, false);\n\n            if (remSubMatrxNum.flat().includes(_num) && !remSubMatrxNum[row_no].includes(_num)) {\n              // That means the num is in the matrix but not in the\n              //part of the row that belongs to this matrix\n              continue;\n            } //yes it can be placed.\n            //Now we need to check whether the remaining number in the\n            //row (numberLeftInRow) can be swaped with the column whose\n            //value we are trying to put\n\n\n            valsInTheTargetCol = this.getRemianingNumbersInColum(_i); // @todo:: Possible optimization. This is only applicable if the \n            // sun-matrix got changed by traversing. \n\n            valsInTheTargetMatrix = this.getRemianingNumbersInSubMatrix(row_no, _i);\n\n            for (var x = 0; x < remRowNums.length; x++) {\n              numberLeftInRow = remRowNums[x];\n\n              if (!valsInTheTargetCol.includes(numberLeftInRow) && !valsInTheTargetMatrix.includes(numberLeftInRow)) {\n                //YES WE CAN SWAP\n                //row_nums[i] =  numberLeftInRow;\n                this.matrix[row_no][_i] = numberLeftInRow;\n                optNum = _num;\n                break;\n              }\n            } //if we have swapped and found the number lets break\n\n\n            if (optNum != -1) {\n              break;\n            }\n          }\n        }\n      }\n\n      if (optNum == -1) {\n        debugger;\n      }\n\n      return optNum;\n    }\n  }, {\n    key: \"getCorrectNum\",\n    value: function getCorrectNum(row_no, col_no) {\n      var row_nums = this.getNumbersInRow(row_no);\n      var col_nums = this.getNumbersInColum(col_no);\n      var sub_matrix_nums = this.getNumbersInSubMatrix(row_no, col_no);\n      var all_nums = row_nums.concat(col_nums).concat(sub_matrix_nums);\n\n      var unique_nums = _toConsumableArray(new Set(all_nums));\n\n      var avlbl_nums = this.VALUE_ARR.filter(function (num) {\n        return !unique_nums.includes(num);\n      }); //if we end up having no avilable numbers lets try to go\n      //back row wise and see which number in this row could \n      //have been placed here\n\n      var new_val = -1;\n\n      if (avlbl_nums.length == 0) {\n        new_val = this.backtrackOptimization(row_no, col_no, row_nums, col_nums, sub_matrix_nums);\n      } else {\n        avlbl_nums = suffle(avlbl_nums);\n        new_val = avlbl_nums.shift();\n      }\n\n      if (new_val == -1) {//debugger;\n        //this.BLANK_CELL_PLACEHOLDER\n      }\n\n      return new_val;\n    }\n  }, {\n    key: \"fillDiagonalSubMatrix\",\n    value: function fillDiagonalSubMatrix() {\n      var row_base = 0,\n          col_base = 0,\n          counter = 1; // we now we have 3 diagonal matrix so we will do the process\n      // 3 times for 3 differen 3 x 3 matrix\n\n      while (counter <= 3) {\n        var num_arr = suffle(_toConsumableArray(this.VALUE_ARR));\n\n        for (var row = row_base; row < row_base + 3; row++) {\n          for (var col = col_base; col < col_base + 3; col++) {\n            var val = num_arr.shift();\n            this.matrix[row][col] = val;\n          }\n        }\n\n        row_base += 3;\n        col_base += 3;\n        counter++;\n      }\n    }\n  }, {\n    key: \"populateCells\",\n    value: function populateCells() {\n      var noSolution = false;\n\n      for (var r = 0; r < 9; r++) {\n        for (var c = 0; c < 9; c++) {\n          var val = this.matrix[r][c];\n\n          if (val === this.BLANK_CELL_PLACEHOLDER) {\n            var correctNum = this.getCorrectNum(r, c);\n\n            if (correctNum == -1) {\n              noSolution = true;\n              break;\n            }\n\n            this.matrix[r][c] = correctNum;\n          }\n        }\n\n        if (noSolution) {\n          break;\n        }\n      }\n\n      if (noSolution) {\n        this.max_try++;\n        console.log(this.max_try + \" Attempting again . . .\");\n        this.generate(); //if(this.max_try > 0) {\n        //    setTimeout(() => {\n        //        this.generate()\n        //    }, 10)\n        //}\n        //else{\n        //    alert(`Sorry! We could not generate even after ${this.max_try} attempts`)\n        // }\n      }\n    }\n  }, {\n    key: \"generate\",\n    value: function generate() {\n      this.matrix = [];\n\n      for (var r = 0; r < 9; r++) {\n        this.matrix[r] = [];\n\n        for (var c = 0; c < 9; c++) {\n          this.matrix[r][c] = this.BLANK_CELL_PLACEHOLDER; //this.getCorrectNum(r, c)\n        }\n      }\n\n      this.fillDiagonalSubMatrix();\n      this.populateCells();\n    }\n  }, {\n    key: \"getCellValue\",\n    value: function getCellValue(row_no, col_nom) {\n      if (!this.matrix[row_no]) {\n        debugger;\n      }\n\n      var num = this.matrix[row_no][col_nom];\n      return num;\n    }\n  }]);\n\n  return SodukuGenerator;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SodukuGenerator);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9Tb2R1a3UvU29kdWt1R2VuZXJhdG9yLmpzPzAyMWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogVGhlIGVuZ2luZSB0byBnZW5lcmF0ZSBhIHNvZHVrdSBQdXp6bGVcbiAgIDEuIFRoZSBiYXNpYyBhbGdvcml0aCB1c2VkIGhlcmUgaXMgdGhhdCB0aGUgMyB4IDMgZGlhZ29uYWwgXG4gICBtYXRyaXggaXMgaW5kZXBlbmRlbnQgb2YgZWFjaCBvdGhlci4gV2Ugc2hvdWxkIGdlbmVyYXRlIFxuICAgdGhvc2UgZmlyc3RcbiAgIDIuIFRoZW4gd2Ugc2hvdWxkIHJhbmRvbWx5IGNob29zZSBhIG51bWJlciBiZXR3ZWVuIDEtOVxuICAgICAgYW5kIGNoZWNrIHdoZXRoZXIgd2UgY2FuIHBsYWNlIHRoYXRcbiAgIDMuIElmIHdlIGNhbiBub3QgcGxhY2UgdGhhdCB0aGVuIHdlIGdvIGJhY2sgdG8gdGhlIHN0ZXAgLSAyXG4gICAgICBhbmQgcmVwZWF0XG4gICA0LiBQb3N0IGNvbXBsZXRpb24gb2YgYWxsIG51bWJlcnMgd2UgcmFuZG9tbHkgcmVtb3ZlIHNvbWUgXG4gICAgICBvZiB0aGUgbnVtYmVycyB0byBjcmVhdGUgdGhlIHB1enpsZVxuKi9cblxuZnVuY3Rpb24gZ2V0UmFuZG9tTnVtIChsaW1pdCA9IDkpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTWF0aC5mbG9vcihsaW1pdCkpO1xufVxuXG5mdW5jdGlvbiBzdWZmbGUoYXJyKSB7XG4gICAgbGV0IGNvcHlBcnIgPSBbLi4uYXJyXVxuICAgIGxldCBsZW4gPSBjb3B5QXJyLmxlbmd0aFxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBsZXQgcm5kX251bSA9IGdldFJhbmRvbU51bShsZW4pXG4gICAgICAgIGxldCB0ZW1wID0gY29weUFycltpXVxuICAgICAgICBjb3B5QXJyW2ldID0gY29weUFycltybmRfbnVtXVxuICAgICAgICBjb3B5QXJyW3JuZF9udW1dID0gdGVtcFxuICAgIH1cbiAgICByZXR1cm4gY29weUFyclxufVxuXG5jbGFzcyBTb2R1a3VHZW5lcmF0b3Ige1xuXG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgICB0aGlzLm1hdHJpeCA9IFtdO1xuICAgICAgICB0aGlzLlZBTFVFX0FSUiA9IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5XTtcbiAgICAgICAgdGhpcy5CTEFOS19DRUxMX1BMQUNFSE9MREVSID0gMDtcbiAgICAgICAgdGhpcy5tYXhfdHJ5ID0gMDtcbiAgICB9XG5cbiAgICAvKiBcbiAgICAgKiBnZXROdW1iZXJzSW5Sb3cgcmV0dXJucyBhbGwgdGhlIG51bWJlcnMgaW4gYSBzcGVjaWZjIHJvdyAgIFxuICAgICovXG4gICAgZ2V0TnVtYmVyc0luUm93IChyb3dfbm8pIHtcbiAgICAgICAgbGV0IG51bXMgPSBbXSwgY29sX2NudHIgPSAwO1xuICAgICAgICB3aGlsZSAoY29sX2NudHIgPCA5KSB7XG4gICAgICAgICAgICBsZXQgdmFsID0gdGhpcy5nZXRDZWxsVmFsdWUocm93X25vLCBjb2xfY250cilcbiAgICAgICAgICAgIGlmKE51bWJlci5pc0ludGVnZXIodmFsKSkge1xuICAgICAgICAgICAgICAgIG51bXMucHVzaCh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29sX2NudHIrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtcztcbiAgICB9XG5cbiAgICBnZXRSZW1pYW5pbmdOdW1iZXJzSW5Sb3cocm93X25vLCByb3dfbnVtcz1bXSkge1xuICAgICAgICBsZXQgbnVtcyA9IHJvd19udW1zLCByZW1haW5pbmdOdW1zID0gW107XG4gICAgICAgIC8vd2hlbiBubyBwcmUtY2F0Y2hlZCByb3dfbnVtcyBoYXMgYmVlbiBwYXNzZWRcbiAgICAgICAgaWYobnVtcy5sZW5ndGggPT0gMCAmJiBOdW1iZXIuaXNJbnRlZ2VyKHJvd19ubykpIHtcbiAgICAgICAgICAgIG51bXMgPSB0aGlzLmdldE51bWJlcnNJblJvdyhyb3dfbm8pXG4gICAgICAgIH1cblxuICAgICAgICByZW1haW5pbmdOdW1zID0gdGhpcy5WQUxVRV9BUlIuZmlsdGVyKG51bSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gIW51bXMuaW5jbHVkZXMobnVtKVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gcmVtYWluaW5nTnVtc1xuICAgIH1cblxuICAgIC8qIFxuICAgICogZ2V0TnVtYmVyc0luUm93IHJldHVybnMgYWxsIHRoZSBudW1iZXJzIGluIGEgc3BlY2lmYyBjb2x1bW4gICBcbiAgICAqL1xuICAgIGdldE51bWJlcnNJbkNvbHVtKGNvbF9ubykge1xuICAgICAgICBsZXQgbnVtcyA9IFtdLCByb3dfY250ciA9IDA7XG4gICAgICAgIHdoaWxlIChyb3dfY250ciA8IDkpIHtcbiAgICAgICAgICAgIGxldCB2YWwgPSB0aGlzLmdldENlbGxWYWx1ZShyb3dfY250ciwgY29sX25vKVxuICAgICAgICAgICAgaWYoTnVtYmVyLmlzSW50ZWdlcih2YWwpKSB7XG4gICAgICAgICAgICAgICAgbnVtcy5wdXNoKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dfY250cisrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudW1zO1xuICAgIH1cblxuICAgIGdldFJlbWlhbmluZ051bWJlcnNJbkNvbHVtKGNvbF9ubywgY29sX251bXMgPSBbXSkge1xuICAgICAgICBsZXQgbnVtcyA9IGNvbF9udW1zLCByZW1haW5pbmdOdW1zID1bXTtcblxuICAgICAgICBpZihudW1zLmxlbmd0aCA9PSAwICYmIE51bWJlci5pc0ludGVnZXIoY29sX25vKSkge1xuICAgICAgICAgICAgbnVtcyA9IHRoaXMuZ2V0TnVtYmVyc0luQ29sdW0oY29sX25vKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZW1haW5pbmdOdW1zID0gdGhpcy5WQUxVRV9BUlIuZmlsdGVyKG51bSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gIW51bXMuaW5jbHVkZXMobnVtKVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gcmVtYWluaW5nTnVtc1xuICAgIH1cblxuICAgIGdldE1hdHJpeExpbWl0IChyb3dfbm8sIGNvbF9ubykge1xuICAgICAgICBsZXQgbWF0cml4X3N0YXJ0X3JvdywgbWF0cml4X2VuZF9yb3csIG1hdHJpeF9zdGFydF9jb2wsIG1hdHJpeF9lbmRfY29sO1xuXG4gICAgICAgIG1hdHJpeF9zdGFydF9yb3cgPSBNYXRoLmZsb29yKHJvd19ubyAvIDMpICogM1xuICAgICAgICBtYXRyaXhfZW5kX3JvdyA9IG1hdHJpeF9zdGFydF9yb3cgKyAyXG4gICAgICAgIG1hdHJpeF9zdGFydF9jb2wgPSBNYXRoLmZsb29yKGNvbF9ubyAvIDMpICogM1xuICAgICAgICBtYXRyaXhfZW5kX2NvbCA9IG1hdHJpeF9zdGFydF9jb2wgKyAyXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdtX3Nfcic6IG1hdHJpeF9zdGFydF9yb3csXG4gICAgICAgICAgICAnbV9lX3InOiBtYXRyaXhfZW5kX3JvdyxcbiAgICAgICAgICAgICdtX3NfYyc6IG1hdHJpeF9zdGFydF9jb2wsXG4gICAgICAgICAgICAnbV9lX2MnOm1hdHJpeF9lbmRfY29sXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBcbiAgICAqIGdldE51bWJlcnNJblN1Yk1hdHJpeCByZXR1cm5zIGFsbCB0aGUgbnVtYmVycyBpbiBhIHNwZWNpZmMgc3ViLW1hdHJpeCAgIFxuICAgICovXG4gICAgZ2V0TnVtYmVyc0luU3ViTWF0cml4KHJvd19ubywgY29sX25vLCBpc0ZsYXQgPSB0cnVlKSB7XG4gICAgICAgIGxldCBudW1zID0gW107XG4gICAgICAgIGxldCBtYXRyaXhfc3RhcnRfcm93LCBtYXRyaXhfZW5kX3JvdywgbWF0cml4X3N0YXJ0X2NvbCwgbWF0cml4X2VuZF9jb2w7XG4gICAgICAgIFxuICAgICAgICBsZXQgbWF0cml4X2NvcmRzID0gdGhpcy5nZXRNYXRyaXhMaW1pdChyb3dfbm8sIGNvbF9ubyk7XG5cbiAgICAgICAgbWF0cml4X3N0YXJ0X3JvdyA9IG1hdHJpeF9jb3Jkcy5tX3NfcjtcbiAgICAgICAgbWF0cml4X2VuZF9yb3cgPSBtYXRyaXhfY29yZHMubV9lX3I7XG4gICAgICAgIG1hdHJpeF9zdGFydF9jb2wgPSBtYXRyaXhfY29yZHMubV9zX2M7XG4gICAgICAgIG1hdHJpeF9lbmRfY29sID0gbWF0cml4X2NvcmRzLm1fZV9jO1xuXG4gICAgICAgIC8vZ2V0IHRoZSB2YWx1ZXMgb2YgdGhpcyBtYXRyaXhcbiAgICAgICAgZm9yKGxldCByb3cgPSBtYXRyaXhfc3RhcnRfcm93OyByb3cgPD0gbWF0cml4X2VuZF9yb3c7IHJvdysrKSB7XG4gICAgICAgICAgICBudW1zW3Jvd10gPSBbXTtcbiAgICAgICAgICAgIGZvcihsZXQgY29sID0gbWF0cml4X3N0YXJ0X2NvbDsgY29sIDw9IG1hdHJpeF9lbmRfY29sOyBjb2wrKykge1xuICAgICAgICAgICAgICAgIGxldCB2YWwgPSB0aGlzLmdldENlbGxWYWx1ZShyb3csIGNvbClcbiAgICAgICAgICAgICAgICBpZihOdW1iZXIuaXNJbnRlZ2VyKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtc1tyb3ddLnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVtcyA9IGlzRmxhdCA/IG51bXMuZmxhdCgpIDogbnVtcztcbiAgICAgICAgXG4gICAgfVxuXG4gICAgZ2V0UmVtaWFuaW5nTnVtYmVyc0luU3ViTWF0cml4KHJvd19ubywgY29sX25vLCBzdW5NYXRyaXhfbnVtcyA9IFtdKSB7XG4gICAgICAgIGxldCBudW1zID0gc3VuTWF0cml4X251bXMsIHJlbWFpbmluZ051bXMgPVtdO1xuXG4gICAgICAgIGlmKG51bXMubGVuZ3RoID09IDAgJiYgTnVtYmVyLmlzSW50ZWdlcihjb2xfbm8pICYmIE51bWJlci5pc0ludGVnZXIocm93X25vKSkge1xuICAgICAgICAgICAgbnVtcyA9IHRoaXMuZ2V0TnVtYmVyc0luU3ViTWF0cml4KHJvd19ubywgY29sX25vKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZW1haW5pbmdOdW1zID0gdGhpcy5WQUxVRV9BUlIuZmlsdGVyKG51bSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gIW51bXMuaW5jbHVkZXMobnVtKVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gcmVtYWluaW5nTnVtc1xuICAgIH1cblxuICAgIC8qXG4gICAgICogVHJ5IHRvIHN1ZmZsZSBwcmV2aW91cyBudW1iZXJzIGluIHRoaXMgcm93IHRvIGZpbmQgYVxuICAgICAqIGR1aXRhYmxlIG51bWJlciBmb3IgdGhpcyBjZWxsXG4gICAgICogQXMgd2UgYXJlIGJhY2t0cmFja2luZyBvbmx5IG9uIHRoZSByb3csIHdlIG5lZWQgbm90IHRvXG4gICAgICogbmV3bHkgZGVyaXZlIHJvdyBudW1iZXJzXG4gICAgICovXG4gICAgYmFja3RyYWNrT3B0aW1pemF0aW9uIChyb3dfbm8sIGNvbF9ubywgcm93X251bXMgPSBbXSwgY29sX251bXMgPSBbXSwgc3ViX21hdHJpeF9udW1zID0gIFtdKSB7XG4gICAgICAgIC8qXG4gICAgICAgICogMS4gV2hpY2ggbnVtYmVyKHMpIGluIHRoaXMgcm93IGFyZSB5ZXQgdG8gYmUgZmlsbGVkIFxuICAgICAgICAqIDIuIFdoaWNoIG51bWJlcihzKSBjYW4gYmUgZmlsbGVkIGluIHRoaXMgY29sdW1uXG4gICAgICAgICogMy4gV2hpY2ggbnVtYmVyKHMpIGNhbiBiZSBmaWxsZWQgaW4gdGhpcyBzdWItbWF0cml4XG4gICAgICAgICovXG4gICAgICAgXG4gICAgICAgIGxldCByZW1Sb3dOdW1zID0gdGhpcy5nZXRSZW1pYW5pbmdOdW1iZXJzSW5Sb3cocm93X25vKTtcbiAgICAgICAgbGV0IHJlbUNvbE51bXMgPSB0aGlzLmdldFJlbWlhbmluZ051bWJlcnNJbkNvbHVtKGNvbF9ubyk7XG4gICAgICAgIGxldCByZW1TdWJNYXRyeE51bSwgdmFsc0luVGhlVGFyZ2V0Q29sLCB2YWxzSW5UaGVUYXJnZXRNYXRyaXgsIG51bWJlckxlZnRJblJvd1xuXG4gICAgICAgIGxldCBvcHROdW0gPSAtMTtcbiAgICAgICAgXG4gICAgICAgIC8vY2FzZSAtIDE6IFdoZW4gdGhlIHJvdyBoYXMgb25seSBvbmUgaXRlbSBsZWZ0IHRvIGZpbGxcbiAgICAgICAgaWYoZmFsc2UpIHsgIC8vcmVtUm93TnVtcy5sZW5ndGggPT0gMVxuICAgICAgICAgICAgLy9kZWJ1Z2dlcjtcbiAgICAgICAgICAgIGxldCBudW1iZXJMZWZ0SW5Sb3cgPSByZW1Sb3dOdW1zWzBdXG4gICAgICAgICAgICAvL3dlIGNhbiBub3cgdHJhdmVyc2UgdGhlIHJvdyBmcm9tIHRoZSBlbmQgdG8gZmluZCB0aGVcbiAgICAgICAgICAgIC8vZmlyc3QgYXZhaWxibGUgbm8gdGhhdCB3ZSBjYW4gcGxhY2UgaW4gdGhpcyBjb2x1bW5cbiAgICAgICAgICAgIGZvcihsZXQgaSA9IGNvbF9uby0xOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGxldCBudW0gPSByb3dfbnVtc1tpXVxuICAgICAgICAgICAgICAgIC8vY2hlY2sgd2hldGhlciB0aGlzIG51bWJlciBjYW4gYmUgcGxhY2VkIGluIHRoZSBcbiAgICAgICAgICAgICAgICAvL3JlcXVpcmVkIGNvbHVtbiAoY29sX251bSlcbiAgICAgICAgICAgICAgICBpZiAocmVtQ29sTnVtcy5pbmNsdWRlcyhudW0pKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9XZSBoYXZlIHRvIGZpbmQgdGhhdCB3aGV0aGVyIHRoZSBzdWItbWF0cml4IGhhcyB0aGlzXG4gICAgICAgICAgICAgICAgICAgIC8vbnVtIG90aGVyIHRoYW4gaXQncyBvd24gcGFydCBvZiB0aGUgcm93IGl0c2VsZlxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVtU3ViTWF0cnhOdW0gPSB0aGlzLmdldE51bWJlcnNJblN1Yk1hdHJpeChyb3dfbm8sIGNvbF9ubywgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIGlmKHJlbVN1Yk1hdHJ4TnVtLmZsYXQoKS5pbmNsdWRlcyhudW0pICYmICFyZW1TdWJNYXRyeE51bVtyb3dfbm9dLmluY2x1ZGVzKG51bSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoYXQgbWVhbnMgdGhlIG51bSBpcyBpbiB0aGUgbWF0cml4IGJ1dCBub3QgaW4gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3BhcnQgb2YgdGhlIHJvdyB0aGF0IGJlbG9uZ3MgdG8gdGhpcyBtYXRyaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8veWVzIGl0IGNhbiBiZSBwbGFjZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vTm93IHdlIG5lZWQgdG8gY2hlY2sgd2hldGhlciB0aGUgcmVtYWluaW5nIG51bWJlciBpbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy9yb3cgKG51bWJlckxlZnRJblJvdykgY2FuIGJlIHN3YXBlZCB3aXRoIHRoZSBjb2x1bW4gd2hvc2VcbiAgICAgICAgICAgICAgICAgICAgLy92YWx1ZSB3ZSBhcmUgdHJ5aW5nIHRvIHB1dFxuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsc0luVGhlVGFyZ2V0Q29sID0gdGhpcy5nZXRSZW1pYW5pbmdOdW1iZXJzSW5Db2x1bShpKVxuICAgICAgICAgICAgICAgICAgICAvLyBAdG9kbzo6IFBvc3NpYmxlIG9wdGltaXphdGlvbi4gVGhpcyBpcyBvbmx5IGFwcGxpY2FibGUgaWYgdGhlIFxuICAgICAgICAgICAgICAgICAgICAvLyBzdW4tbWF0cml4IGdvdCBjaGFuZ2VkIGJ5IHRyYXZlcnNpbmcuIFxuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsc0luVGhlVGFyZ2V0TWF0cml4ID0gdGhpcy5nZXRSZW1pYW5pbmdOdW1iZXJzSW5TdWJNYXRyaXgocm93X25vLCBpKSBcbiAgICAgICAgICAgICAgICAgICAgaWYoIXZhbHNJblRoZVRhcmdldENvbC5pbmNsdWRlcyhudW1iZXJMZWZ0SW5Sb3cpICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgIXZhbHNJblRoZVRhcmdldE1hdHJpeC5pbmNsdWRlcyhudW1iZXJMZWZ0SW5Sb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1lFUyBXRSBDQU4gU1dBUFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yb3dfbnVtc1tpXSA9ICBudW1iZXJMZWZ0SW5Sb3c7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeFtyb3dfbm9dW2ldID0gbnVtYmVyTGVmdEluUm93XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHROdW0gPSBudW1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vZGVidWdnZXI7XG4gICAgICAgICAgICBmb3IobGV0IGkgPSBjb2xfbm8tMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgbnVtID0gcm93X251bXNbaV1cbiAgICAgICAgICAgICAgICAvL2NoZWNrIHdoZXRoZXIgdGhpcyBudW1iZXIgY2FuIGJlIHBsYWNlZCBpbiB0aGUgXG4gICAgICAgICAgICAgICAgLy9yZXF1aXJlZCBjb2x1bW4gKGNvbF9udW0pXG4gICAgICAgICAgICAgICAgaWYgKHJlbUNvbE51bXMuaW5jbHVkZXMobnVtKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vV2UgaGF2ZSB0byBmaW5kIHRoYXQgd2hldGhlciB0aGUgc3ViLW1hdHJpeCBoYXMgdGhpc1xuICAgICAgICAgICAgICAgICAgICAvL251bSBvdGhlciB0aGFuIGl0J3Mgb3duIHBhcnQgb2YgdGhlIHJvdyBpdHNlbGZcbiAgICAgICAgICAgICAgICAgICAgcmVtU3ViTWF0cnhOdW0gPSB0aGlzLmdldE51bWJlcnNJblN1Yk1hdHJpeChyb3dfbm8sIGNvbF9ubywgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIGlmKHJlbVN1Yk1hdHJ4TnVtLmZsYXQoKS5pbmNsdWRlcyhudW0pICYmICFyZW1TdWJNYXRyeE51bVtyb3dfbm9dLmluY2x1ZGVzKG51bSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoYXQgbWVhbnMgdGhlIG51bSBpcyBpbiB0aGUgbWF0cml4IGJ1dCBub3QgaW4gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3BhcnQgb2YgdGhlIHJvdyB0aGF0IGJlbG9uZ3MgdG8gdGhpcyBtYXRyaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8veWVzIGl0IGNhbiBiZSBwbGFjZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vTm93IHdlIG5lZWQgdG8gY2hlY2sgd2hldGhlciB0aGUgcmVtYWluaW5nIG51bWJlciBpbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy9yb3cgKG51bWJlckxlZnRJblJvdykgY2FuIGJlIHN3YXBlZCB3aXRoIHRoZSBjb2x1bW4gd2hvc2VcbiAgICAgICAgICAgICAgICAgICAgLy92YWx1ZSB3ZSBhcmUgdHJ5aW5nIHRvIHB1dFxuICAgICAgICAgICAgICAgICAgICB2YWxzSW5UaGVUYXJnZXRDb2wgPSB0aGlzLmdldFJlbWlhbmluZ051bWJlcnNJbkNvbHVtKGkpXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0b2RvOjogUG9zc2libGUgb3B0aW1pemF0aW9uLiBUaGlzIGlzIG9ubHkgYXBwbGljYWJsZSBpZiB0aGUgXG4gICAgICAgICAgICAgICAgICAgIC8vIHN1bi1tYXRyaXggZ290IGNoYW5nZWQgYnkgdHJhdmVyc2luZy4gXG4gICAgICAgICAgICAgICAgICAgIHZhbHNJblRoZVRhcmdldE1hdHJpeCA9IHRoaXMuZ2V0UmVtaWFuaW5nTnVtYmVyc0luU3ViTWF0cml4KHJvd19ubywgaSkgXG5cblxuICAgICAgICAgICAgICAgICAgICBmb3IobGV0IHggPSAwOyB4IDwgcmVtUm93TnVtcy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyTGVmdEluUm93ID0gcmVtUm93TnVtc1t4XVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXZhbHNJblRoZVRhcmdldENvbC5pbmNsdWRlcyhudW1iZXJMZWZ0SW5Sb3cpICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIXZhbHNJblRoZVRhcmdldE1hdHJpeC5pbmNsdWRlcyhudW1iZXJMZWZ0SW5Sb3cpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ZRVMgV0UgQ0FOIFNXQVBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3Jvd19udW1zW2ldID0gIG51bWJlckxlZnRJblJvdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeFtyb3dfbm9dW2ldID0gbnVtYmVyTGVmdEluUm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0TnVtID0gbnVtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL2lmIHdlIGhhdmUgc3dhcHBlZCBhbmQgZm91bmQgdGhlIG51bWJlciBsZXRzIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIGlmKG9wdE51bSAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKG9wdE51bSA9PSAtMSkge1xuICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3B0TnVtO1xuICAgIH1cblxuXG4gICAgZ2V0Q29ycmVjdE51bShyb3dfbm8sIGNvbF9ubykge1xuICAgICAgICBsZXQgcm93X251bXMgPSB0aGlzLmdldE51bWJlcnNJblJvdyhyb3dfbm8pO1xuICAgICAgICBsZXQgY29sX251bXMgPSB0aGlzLmdldE51bWJlcnNJbkNvbHVtKGNvbF9ubyk7XG4gICAgICAgIGxldCBzdWJfbWF0cml4X251bXMgPSB0aGlzLmdldE51bWJlcnNJblN1Yk1hdHJpeChyb3dfbm8sIGNvbF9ubylcblxuICAgICAgICBsZXQgYWxsX251bXMgPSByb3dfbnVtcy5jb25jYXQoY29sX251bXMpLmNvbmNhdChzdWJfbWF0cml4X251bXMpXG4gICAgICAgIGxldCB1bmlxdWVfbnVtcyA9IFsuLi4gbmV3IFNldChhbGxfbnVtcyldXG5cbiAgICAgICAgbGV0IGF2bGJsX251bXMgPSB0aGlzLlZBTFVFX0FSUi5maWx0ZXIobnVtID0+IHtcbiAgICAgICAgICAgIHJldHVybiAhdW5pcXVlX251bXMuaW5jbHVkZXMobnVtKVxuICAgICAgICB9KVxuXG4gICAgICAgIC8vaWYgd2UgZW5kIHVwIGhhdmluZyBubyBhdmlsYWJsZSBudW1iZXJzIGxldHMgdHJ5IHRvIGdvXG4gICAgICAgIC8vYmFjayByb3cgd2lzZSBhbmQgc2VlIHdoaWNoIG51bWJlciBpbiB0aGlzIHJvdyBjb3VsZCBcbiAgICAgICAgLy9oYXZlIGJlZW4gcGxhY2VkIGhlcmVcbiAgICAgICAgbGV0IG5ld192YWwgPSAtMVxuICAgICAgICBpZihhdmxibF9udW1zLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBuZXdfdmFsID0gdGhpcy5iYWNrdHJhY2tPcHRpbWl6YXRpb24ocm93X25vLCBjb2xfbm8sIHJvd19udW1zLCBjb2xfbnVtcywgc3ViX21hdHJpeF9udW1zKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXZsYmxfbnVtcyA9IHN1ZmZsZShhdmxibF9udW1zKVxuICAgICAgICAgICAgbmV3X3ZhbCA9IGF2bGJsX251bXMuc2hpZnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKG5ld192YWwgPT0gLTEpIHtcbiAgICAgICAgICAgIC8vZGVidWdnZXI7XG4gICAgICAgICAgICAvL3RoaXMuQkxBTktfQ0VMTF9QTEFDRUhPTERFUlxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdfdmFsO1xuICAgIH1cbiAgICBcbiAgICBmaWxsRGlhZ29uYWxTdWJNYXRyaXggKCkge1xuICAgICAgICBsZXQgcm93X2Jhc2UgPSAwLCBjb2xfYmFzZSA9IDAsIGNvdW50ZXIgPSAxO1xuICAgICAgICAvLyB3ZSBub3cgd2UgaGF2ZSAzIGRpYWdvbmFsIG1hdHJpeCBzbyB3ZSB3aWxsIGRvIHRoZSBwcm9jZXNzXG4gICAgICAgIC8vIDMgdGltZXMgZm9yIDMgZGlmZmVyZW4gMyB4IDMgbWF0cml4XG4gICAgICAgIHdoaWxlIChjb3VudGVyIDw9IDMpIHtcbiAgICAgICAgICAgIGxldCBudW1fYXJyID0gc3VmZmxlKFsuLi50aGlzLlZBTFVFX0FSUl0pXG4gICAgICAgICAgICBmb3IobGV0IHJvdyA9IHJvd19iYXNlOyByb3cgPCAocm93X2Jhc2UrMyk7IHJvdysrKSB7XG4gICAgICAgICAgICAgICAgZm9yKGxldCBjb2wgPSBjb2xfYmFzZTsgY29sIDwgKGNvbF9iYXNlKzMpOyBjb2wrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsID0gbnVtX2Fyci5zaGlmdCgpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0cml4W3Jvd11bY29sXSA9IHZhbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd19iYXNlICs9IDM7XG4gICAgICAgICAgICBjb2xfYmFzZSArPSAzO1xuICAgICAgICAgICAgY291bnRlcisrXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwb3B1bGF0ZUNlbGxzICgpIHtcbiAgICAgICAgbGV0IG5vU29sdXRpb24gPSBmYWxzZVxuICAgICAgICBmb3IobGV0IHIgPSAwOyByIDwgOTsgcisrKSB7XG4gICAgICAgICAgICBmb3IobGV0IGMgPSAwOyBjIDwgOTsgYysrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbCA9IHRoaXMubWF0cml4W3JdW2NdO1xuICAgICAgICAgICAgICAgIGlmKHZhbCA9PT0gdGhpcy5CTEFOS19DRUxMX1BMQUNFSE9MREVSKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb3JyZWN0TnVtID0gdGhpcy5nZXRDb3JyZWN0TnVtKHIsIGMpO1xuICAgICAgICAgICAgICAgICAgICBpZihjb3JyZWN0TnVtID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub1NvbHV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRyaXhbcl1bY10gPSBjb3JyZWN0TnVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKG5vU29sdXRpb24pIHtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYobm9Tb2x1dGlvbikge1xuICAgICAgICAgICAgdGhpcy5tYXhfdHJ5ICsrXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLm1heF90cnkrIFwiIEF0dGVtcHRpbmcgYWdhaW4gLiAuIC5cIilcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGUoKVxuICAgICAgICAgICAgLy9pZih0aGlzLm1heF90cnkgPiAwKSB7XG4gICAgICAgICAgICAvLyAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIC8vICAgICAgICB0aGlzLmdlbmVyYXRlKClcbiAgICAgICAgICAgIC8vICAgIH0sIDEwKVxuICAgICAgICAgICAgLy99XG4gICAgICAgICAgICAvL2Vsc2V7XG4gICAgICAgICAgICAvLyAgICBhbGVydChgU29ycnkhIFdlIGNvdWxkIG5vdCBnZW5lcmF0ZSBldmVuIGFmdGVyICR7dGhpcy5tYXhfdHJ5fSBhdHRlbXB0c2ApXG4gICAgICAgICAgIC8vIH1cblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2VuZXJhdGUgKCkge1xuICAgICAgICB0aGlzLm1hdHJpeCA9IFtdO1xuICAgICAgICBmb3IobGV0IHIgPSAwOyByIDwgOTsgcisrKSB7XG4gICAgICAgICAgICB0aGlzLm1hdHJpeFtyXSA9IFtdXG4gICAgICAgICAgICBmb3IobGV0IGMgPSAwOyBjIDwgOTsgYysrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRyaXhbcl1bY10gPSB0aGlzLkJMQU5LX0NFTExfUExBQ0VIT0xERVIgLy90aGlzLmdldENvcnJlY3ROdW0ociwgYylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbGxEaWFnb25hbFN1Yk1hdHJpeCgpXG4gICAgICAgIHRoaXMucG9wdWxhdGVDZWxscygpXG4gICAgfVxuXG4gICAgZ2V0Q2VsbFZhbHVlIChyb3dfbm8sIGNvbF9ub20pIHtcbiAgICAgICAgaWYoIXRoaXMubWF0cml4W3Jvd19ub10pIHtcbiAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBsZXQgbnVtID0gdGhpcy5tYXRyaXhbcm93X25vXVtjb2xfbm9tXVxuICAgICAgICByZXR1cm4gbnVtXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTb2R1a3VHZW5lcmF0b3I7Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7O0FBWUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBRUE7Ozs7OztBQUdBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFNQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBLGdIQXFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBR0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(4);\n            var content = __webpack_require__(5);\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zdHlsZXMvbWFpbi5jc3M/ZTgwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbWFpbi5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : undefined;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && btoa) {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcz8yZGJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gIHZhciBtZW1vO1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcbiAgICAgIC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcbiAgICAgIC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcbiAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG4gICAgICBtZW1vID0gQm9vbGVhbih3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG59KCk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gIHZhciBtZW1vID0ge307XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpIHtcbiAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbiAgfTtcbn0oKTtcblxudmFyIHN0eWxlc0luRG9tID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5Eb20ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5Eb21baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXVxuICAgIH07XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzSW5Eb20ucHVzaCh7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cblxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHZhciBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuXG4gIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gICAgaWYgKG5vbmNlKSB7XG4gICAgICBhdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG52YXIgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmoubWVkaWEgPyBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpLmNvbmNhdChvYmouY3NzLCBcIn1cIikgOiBvYmouY3NzOyAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH1cblxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzcztcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnbWVkaWEnKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXAgJiYgYnRvYSkge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGUuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXIgc2luZ2xldG9uQ291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgc3R5bGU7XG4gIHZhciB1cGRhdGU7XG4gIHZhciByZW1vdmU7XG5cbiAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgc3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG9iaik7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4gIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcblxuICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gIH1cblxuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0xpc3QpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRG9tW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRvbVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRvbS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

eval("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(6);\nexports = ___CSS_LOADER_API_IMPORT___(false);\n// Module\nexports.push([module.i, \"body {\\n    background-color: lightgreen;\\n    box-sizing: border-box;\\n}\\n\\n.row {\\n    /* border: 1px solid #333; */\\n    margin: 0px;\\n    max-height: 40px;\\n    display: flex;\\n}\\n\\n.top_row {\\n    border-top: 1px solid black;\\n}\\n\\n.row_divider {\\n    border-bottom: 2px solid black;\\n}\\n\\n.cell {\\n    border-left: 1px solid #999;\\n    border-top: 1px solid #999;\\n    display: inline-block;\\n    width: 40px;\\n    height: 40px;\\n    padding: 5px;\\n    margin: 0px;\\n    line-height: 24px;\\n    text-align: center;\\n    justify-content: center;\\n}\\n\\n.empty-cell {\\n    background-color: white;\\n}\\n\\n.left-cell {\\n    border-left: 2px solid black;\\n}\\n\\n.cell_right {\\n    border-right: 2px solid black\\n}\\n\\n.cell-text {\\n    font-size: 1.2em;\\n    font-weight: bold;\\n}\\n\\n#soduku-board {\\n    margin-top: 80px;\\n    margin-left: 80px;\\n    position: absolute;\\n    background-color: lightyellow;\\n    padding: 5px;\\n}\", \"\"]);\n// Exports\nmodule.exports = exports;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zdHlsZXMvbWFpbi5jc3M/NTYwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIik7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiYm9keSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IGxpZ2h0Z3JlZW47XFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcblxcbi5yb3cge1xcbiAgICAvKiBib3JkZXI6IDFweCBzb2xpZCAjMzMzOyAqL1xcbiAgICBtYXJnaW46IDBweDtcXG4gICAgbWF4LWhlaWdodDogNDBweDtcXG4gICAgZGlzcGxheTogZmxleDtcXG59XFxuXFxuLnRvcF9yb3cge1xcbiAgICBib3JkZXItdG9wOiAxcHggc29saWQgYmxhY2s7XFxufVxcblxcbi5yb3dfZGl2aWRlciB7XFxuICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCBibGFjaztcXG59XFxuXFxuLmNlbGwge1xcbiAgICBib3JkZXItbGVmdDogMXB4IHNvbGlkICM5OTk7XFxuICAgIGJvcmRlci10b3A6IDFweCBzb2xpZCAjOTk5O1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIHdpZHRoOiA0MHB4O1xcbiAgICBoZWlnaHQ6IDQwcHg7XFxuICAgIHBhZGRpbmc6IDVweDtcXG4gICAgbWFyZ2luOiAwcHg7XFxuICAgIGxpbmUtaGVpZ2h0OiAyNHB4O1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbn1cXG5cXG4uZW1wdHktY2VsbCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbn1cXG5cXG4ubGVmdC1jZWxsIHtcXG4gICAgYm9yZGVyLWxlZnQ6IDJweCBzb2xpZCBibGFjaztcXG59XFxuXFxuLmNlbGxfcmlnaHQge1xcbiAgICBib3JkZXItcmlnaHQ6IDJweCBzb2xpZCBibGFja1xcbn1cXG5cXG4uY2VsbC10ZXh0IHtcXG4gICAgZm9udC1zaXplOiAxLjJlbTtcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcblxcbiNzb2R1a3UtYm9hcmQge1xcbiAgICBtYXJnaW4tdG9wOiA4MHB4O1xcbiAgICBtYXJnaW4tbGVmdDogODBweDtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBsaWdodHllbGxvdztcXG4gICAgcGFkZGluZzogNXB4O1xcbn1cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join('');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === 'string') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || '').concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n  return \"/*# \".concat(data, \" */\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanM/MjRmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXNlU291cmNlTWFwKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgcmV0dXJuIFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChjb250ZW50LCBcIn1cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oJycpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gKG1vZHVsZXMsIG1lZGlhUXVlcnksIGRlZHVwZSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgJyddXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19pXSk7XG5cbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYVF1ZXJ5KSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMl0gPSBcIlwiLmNvbmNhdChtZWRpYVF1ZXJ5LCBcIiBhbmQgXCIpLmNvbmNhdChpdGVtWzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcblxuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCAnJykuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufSAvLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5cblxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG4gIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgcmV0dXJuIFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n");

/***/ })
/******/ ]);